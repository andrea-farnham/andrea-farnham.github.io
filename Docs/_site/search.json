[
  {
    "objectID": "contents/about/About.html",
    "href": "contents/about/About.html",
    "title": "About",
    "section": "",
    "text": "A Framework for Avoiding the Open Research Data Dump.\nThe project AFFORD aims at designing a sustainable support framework to lower the barriers to publishing data and other research outputs in an accessible form by bundling know-how, workflows, and tools under the umbrella of one organizational entity. It is a collaboration between the InterfaceGroup and the Center for Reproducible Science of the University of Zurich. It uses the Sinergia project Fluid Dynamics of the central nervous system as a reference project and accompanies this project in the full cycle of Open Research Data (ORD) generation from experiment planning to publishing. This project-based, data-driven approach will help the framework reach a sufficient level of maturity before it is made available to all university researchers.\n\n\n\nThe reproducibility of scientific findings is crucial for the credibility of empirical research. The objective of the Center for Reproducible Science is to train the next generation of researchers in good research practices, to develop novel methodology related to reproducibility and replicability, and to improve the quality of scientific investigation using meta-science.\nThe CRS is a competence center supported by the Vice President Research and by the Faculties of Medicine (MeF, leading house), Science (MNF), Business, Economics and Informatics (WWF), Arts and Social Sciences (PhF), Law (RWF), and Vetsuisse Faculty (VSF)."
  },
  {
    "objectID": "contents/about/About.html#the-afford-project",
    "href": "contents/about/About.html#the-afford-project",
    "title": "About",
    "section": "",
    "text": "A Framework for Avoiding the Open Research Data Dump.\nThe project AFFORD aims at designing a sustainable support framework to lower the barriers to publishing data and other research outputs in an accessible form by bundling know-how, workflows, and tools under the umbrella of one organizational entity. It is a collaboration between the InterfaceGroup and the Center for Reproducible Science of the University of Zurich. It uses the Sinergia project Fluid Dynamics of the central nervous system as a reference project and accompanies this project in the full cycle of Open Research Data (ORD) generation from experiment planning to publishing. This project-based, data-driven approach will help the framework reach a sufficient level of maturity before it is made available to all university researchers."
  },
  {
    "objectID": "contents/about/About.html#the-crs",
    "href": "contents/about/About.html#the-crs",
    "title": "About",
    "section": "",
    "text": "The reproducibility of scientific findings is crucial for the credibility of empirical research. The objective of the Center for Reproducible Science is to train the next generation of researchers in good research practices, to develop novel methodology related to reproducibility and replicability, and to improve the quality of scientific investigation using meta-science.\nThe CRS is a competence center supported by the Vice President Research and by the Faculties of Medicine (MeF, leading house), Science (MNF), Business, Economics and Informatics (WWF), Arts and Social Sciences (PhF), Law (RWF), and Vetsuisse Faculty (VSF)."
  },
  {
    "objectID": "contents/presentations/Presentations.html",
    "href": "contents/presentations/Presentations.html",
    "title": "Presentations",
    "section": "",
    "text": "Presentations\nCollection of presentations related to AFFORD project\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nNov 7, 2023\n\n\nAFFORD deliverables - ORD Hub\n\n\nG.Fraga Gonzalez\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "contents/presentations/Presentations_1.html",
    "href": "contents/presentations/Presentations_1.html",
    "title": "AFFORD deliverables - ORD Hub",
    "section": "",
    "text": "Back\n\nAFFORD deliverables - ORD Hub\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/reports/Reports.html",
    "href": "contents/reports/Reports.html",
    "title": "Reports",
    "section": "",
    "text": "Reports\nCollection of reports from the AFFORD project\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nOct 11, 2023\n\n\nReport 1 Data Archiving\n\n\nG.Fraga Gonzalez & E. Furrer\n\n\n\n\nOct 5, 2023\n\n\nReport 2 Another test pdf\n\n\nG.Fraga Gonzalez & E. Furrer\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "contents/reports/Reports_1.html",
    "href": "contents/reports/Reports_1.html",
    "title": "Report 1 Data Archiving",
    "section": "",
    "text": "Report 1 Data Archiving\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/reports/Reports_2.html",
    "href": "contents/reports/Reports_2.html",
    "title": "Report 2 Another test pdf",
    "section": "",
    "text": "Report 2 Another test pdf\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tools/Tools.html",
    "href": "contents/tools/Tools.html",
    "title": "Tools",
    "section": "",
    "text": "Tools\nThis collection of interactive tools is work in progress…\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nExample 1 Shinylive in Quarto\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "contents/tools/Tools_1.html",
    "href": "contents/tools/Tools_1.html",
    "title": "Example 1 Shinylive in Quarto",
    "section": "",
    "text": "This might take a while to load….\n#| standalone: true\n#| viewerHeight: 420\n  \nui &lt;- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"file1\", \"Choose CSV File\", accept = \".csv\"),\n      checkboxInput(\"header\", \"Header\", TRUE)\n    ),\n    mainPanel(\n      tableOutput(\"contents\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$contents &lt;- renderTable({\n    file &lt;- input$file1\n    ext &lt;- tools::file_ext(file$datapath)\n    \n    req(file)\n    validate(need(ext == \"csv\", \"Please upload a csv file\"))\n    \n    read.csv(file$datapath, header = input$header)\n  })\n}\n\nshinyApp(ui, server)\n \n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Gitlab/index.html",
    "href": "contents/tutorials/Gitlab/index.html",
    "title": "Gitlab for Open Research Data",
    "section": "",
    "text": "Gitlab for Open Research Data\nA series of practical tutorials for setting a Gitlab repository for data (and metadata) sharing\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nA Gitlab workflow to data sharing\n\n\nG.Fraga Gonzalez & E. Furrer\n\n\n\n\nGitlab Tutorial 1: Using a UZH Gitlab repository for Project Owners and Collaborators\n\n\nG.Fraga Gonzalez & E. Furrer\n\n\n\n\nGitlab Tutorial 2: Creating and Updating a Data Hub\n\n\nG.Fraga Gonzalez & E. Furrer\n\n\n\n\nGitlab Tutorial 3: Customizing Continuous Integration\n\n\nG.Fraga Gonzalez & E. Furrer\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Gitlab/Tutorial-0.-Main-workflow.html",
    "href": "contents/tutorials/Gitlab/Tutorial-0.-Main-workflow.html",
    "title": "A Gitlab workflow to data sharing",
    "section": "",
    "text": "Back\n\nA Gitlab workflow to data sharing\nThe owner of the data (e.g., a lab or a researcher) creates and maintains a main Gitlab repository containing:\n\nMetadata\nData, if applicable, e.g., thumbnail images\nScripts to render an HTML landing site, i.e. the Data Hub, which provides access for collaborators.\nDocumentation associated with those data is collected in the Wiki of the main repository. The markdown files composing the Wiki can be downloaded (they are stored is a separate repository) or they can be directly edited in the browser through the main repository.\n\nThe materials will have three url locations, which can all be accessed through the Data Hub page:\n\nThe Landing page provides the interactive hub and links to the source metadata locations and the documentation.\nThe main repository to access the source metadata tables and data files\nThe Wiki to access all related documentation such as protocols and SOPs. The Wiki is alsa accessible through the main repository.\n\nAny collaborator is given the landing page address and access credentials to it. From there they can access the three urls.\n\n\n\nGitlab_basic\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Gitlab/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html",
    "href": "contents/tutorials/Gitlab/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html",
    "title": "Gitlab Tutorial 1: Using a UZH Gitlab repository for Project Owners and Collaborators",
    "section": "",
    "text": "Back"
  },
  {
    "objectID": "contents/tutorials/Gitlab/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#personal-access-token",
    "href": "contents/tutorials/Gitlab/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#personal-access-token",
    "title": "Gitlab Tutorial 1: Using a UZH Gitlab repository for Project Owners and Collaborators",
    "section": "Personal access token",
    "text": "Personal access token\nTo clone a repository to your machine you will most likely need a personal access token (due to the security of SWITCH login). In your project repository on Gitlab.uzh.ch go to Settings/Access tokens. In the Access Tokens menu you will be able to give the token a name, choose an expiration date (or leave it blank), choose permissions (choose at least developer for making edits) and scope (select API). See also the picture below.\n\n\n\nimage\n\n\nAfter this you will see a long alphanumeric string, the token, that you should save somewhere so you can use it as your password later on when using Github-desktop, Git or any other platform to manage local copies of the repositories."
  },
  {
    "objectID": "contents/tutorials/Gitlab/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-github-desktop-user-friendly",
    "href": "contents/tutorials/Gitlab/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-github-desktop-user-friendly",
    "title": "Gitlab Tutorial 1: Using a UZH Gitlab repository for Project Owners and Collaborators",
    "section": "2.1 Cloning with Github-desktop (user-friendly)",
    "text": "2.1 Cloning with Github-desktop (user-friendly)\nThe open source tool Github-desktop with a graphical user interface will simplify pull, commit, push operations for both advanced as well as new users. !Note: official support seems to be only for Windows and Mac. See further documentation on integration with Gitlab\n\nSetup of Github-desktop for Gitlab\n\nDownload and install Github desktop\nIn your Gitlab project, get your personal access token (see above) and save it somewhere\nOn Github desktop go to File/Clone repository. Then enter the URL of your Gitlab repository (see the clone button) and a local directory name. For example:\n\nThen you will be asked for username and password. Your username is your Gitlab username (e.g., the name in your email address) and the password is the Token that you just created.\n\nNow your Local folder is linked to your Gitlab remote repository. You can check below how to pull, commit and push changes.\n\n\nEditing repository\nPull,commit and Push changes in the content of the repository. The workflow can get quite complex. Here we will ignore elements like branches to oversimplify it into the main steps:\n\nWork on your local repository, for example, create or edit code, update your metadata table, add new files [^1]\nOpen Github desktop. If you have several repositories, make sure you select the one you are currently working on or the one you want to update. It should detect the local changes done. If there are changes done remotely, but not locally, it willl prompt you to pull those changes (but here, beware there may be conflicts, which you shold be able to solve with Github but may complicate things).\nClick Commit ( you will need to write a brief description, e.g., ‘updated figures’). This will prepare your changes to be sent to the remote repository (‘origin’). If you edited multiple scripts, you can commit all changes at once or select specific scripts\nClick push to origin so that the changes are uploaded.\n\n[^1]: Gitlab is not intended as a large data storage. For the pages in this example we need to have the pictures we want to render in the repository. But sometimes we have many files in our local repository that we do not want to push to the online repository. For that we can use a plain text file in that directory and call it .gitignore. In that file we can have statements like ‘*.jpg’. Then Git will ignore all jpg files in the folder when pushing."
  },
  {
    "objectID": "contents/tutorials/Gitlab/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-git",
    "href": "contents/tutorials/Gitlab/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-git",
    "title": "Gitlab Tutorial 1: Using a UZH Gitlab repository for Project Owners and Collaborators",
    "section": "2.2 Cloning with Git",
    "text": "2.2 Cloning with Git\nGit refers to this version control system used in Gitlab, but you can also manage the repositories locally downloading the program Git SCM, a free and open source distributed version control system. It is light and works across operating systems, and also has a very basic graphical interface. But it is mostly designed for working through a terminal. As in Github-desktop you use this to do the main Git actions of pulling, committing and pushing changes between local and remote repositories."
  },
  {
    "objectID": "contents/tutorials/Gitlab/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html",
    "href": "contents/tutorials/Gitlab/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html",
    "title": "Gitlab Tutorial 2: Creating and Updating a Data Hub",
    "section": "",
    "text": "Back\n\nGitlab Tutorial 2: Creating and Updating a Data Hub\nThe static site generated in this repository shows an interactive table with image thumbnails (clickable). By static we mean that the user will just see whatever data is contained in the HTML of the site. Although it contains an interactive table, all users have access to the same data which they cannot modify (unlike in dynamic websites).\nThe website hosted using Gitlab pages is rendered with an [R Markdown] (https://rmarkdown.rstudio.com/) script, that uses the R DT package). The script creates an interactive page in HTML. Gitlab CI is used to run the R Markdown script automatically at each update (push) and render the site from the browser so that users do not need to install R or other programs to update the site.\n\n\nWorkflow for data owners\n\n\n1. ACTION: Owner edits metadata\nThe owner can do this through:\n\nBrowser (RECOMMENDED FOR MINOR CHANGES) Making changes from Gitlab in the browser (upload or edit file)\nClone repository (RECOMMENDED FOR MAJOR UPDATES) Cloning this repo, working locally and committing and pushing the changes to Gitlab (e.g., using Github desktop). The local metadata file should be always in Sync with that one in the remote repository.\n\nNOTE: The files in the Gitlab repository should be considered as the main source for retrieving your projects’ metadata.\n\n\n2. AUTO: changes in the repository trigger the Continuous Integration pipeline\nIt may take around 5 minutes to update the page html. The member with at least maintainer status can click on Build/Pipelines or Jobs (sidebar in Gitlab) to see what pipeline or job (within pipeline) is running, and if there are any errors.\n\n\n3. AUTO: the continuous integration pipeline runs the script\nThe .gitlab-ci.yml file defines this pipeline. It uses a Docker image with R, Gitlab pages to produce the website, and Gitlab runner to run the Docker where we have our Rmarkdown script (rendering the html from the table). The owner can edit the yml and the Rmarkdown to make if changes in this flow are to be done. No edit of Docker image is needed.\nSee our tutorial on customizing Gitlab Continuous Integration for more advanced details.\n\n\n4. AUTO: The HTML is updated and collaborators can navigate through the updated data\n\n\n\nFiles\nThe main input files are:\n\nmetadata table (preferrably in .csv format for interoperability). It should contain just the filename of the pictures that will be displayed\nimages files (Note: Gitlab is not meant for data storage. Images should be compressed to avoid exceeding volume allowed per repo ( usually 5 Gb in free versions, details here)\nR markdown script that has the code to render the table with DT package\nA .gitlab-ci.yml file is the Continuous integration file that makes it possible to run the Rmd file and render the html again from Gitlab\n\nThe outputs for the website\n\nindex.html file within the public folder\nAn ’ files’ folder will be saved if the table is rendered as self-contained\n\nNote: index.html and images folder ARE EXPECTED to be saved in the public folder. This does not mean they are publicly accessible (you need login to access this site)\n\n\nPrivacy\nThis is a private repository and a private site\n\nAccounts. A SWITCH account is required to access the static website and the repository with the code to generate it\nMembers. A maintainer member in this repository can add new members (Go to Manage/Members). They must be also maintainer to be able to access the images after clicking on the table thumbnail. Guests can only see the thumbnails\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Gitlab/Tutorial-3.-Customizing-Gitlab-Continuous-Integration.html",
    "href": "contents/tutorials/Gitlab/Tutorial-3.-Customizing-Gitlab-Continuous-Integration.html",
    "title": "Gitlab Tutorial 3: Customizing Continuous Integration",
    "section": "",
    "text": "Back"
  },
  {
    "objectID": "contents/tutorials/Gitlab/Tutorial-3.-Customizing-Gitlab-Continuous-Integration.html#the-.gitlab-ci.yml-file",
    "href": "contents/tutorials/Gitlab/Tutorial-3.-Customizing-Gitlab-Continuous-Integration.html#the-.gitlab-ci.yml-file",
    "title": "Gitlab Tutorial 3: Customizing Continuous Integration",
    "section": "The .gitlab-ci.yml file",
    "text": "The .gitlab-ci.yml file\nThis is the file that will define the pipeline which we can run from the browser.\n\nThe first part loads a docker image (similar to a snapshot of a virtual machine).\nThen it defines different stages (deploy is the main, but some tests stages are usually included as well). Sometimes there is a before the script section with some installations (not present in this example).\nThen the main script in this example runs some R code, using the R markdown package, to render the R markdown script named ‘R_interactive_table.Rmd’. In this case the render command outputs the html directly in the public folder. Note the index.html will only be visible if you go to Pipelines/\nGitlab pages expects the output HTML to be saved in a server named public.\n\n\nNote: below we show just an example. The actual file may have change and can be found in the repository.\n\nimage: rocker/verse:4.0.0\npages:\n  stage: deploy\n  script:\n  - R -e \"baseDir &lt;- getwd(); rmarkdown::render('_scripts/R_interactive_table.Rmd', output_file = file.path(baseDir,'public','index.html'))\"\n        \n\n  artifacts:    \n    paths:\n    - public    \n    - public/Images\n    \n  only:\n  - master\n  interruptible: true"
  },
  {
    "objectID": "contents/tutorials/index.html",
    "href": "contents/tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\nA series of practical tutorials for managing Open Research Data\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\nSubtitle\n\n\nDate\n\n\n\n\n\n\nEasy-to-build website with R and Quarto\n\n\nMake a platform to share data, code and outputs in dynamic reports\n\n\nNov 15, 2023\n\n\n\n\nGitlab Tutorial 0 - Workflow\n\n\nA workflow for Gitlab as a platform for sharing research documentation, metadata and data\n\n\nNov 16, 2023\n\n\n\n\nGitlab Tutorial 1 - short step-by-step guide to Git and Gitlab\n\n\nUsing a UZH Gitlab repository for Project Owners and Collaborators\n\n\nNov 16, 2023\n\n\n\n\nGitlab Tutorial 2 - Creating and Updating a Data Hub\n\n\nQuick explanation on using Gitlab pages as an open data hub\n\n\nNov 16, 2023\n\n\n\n\nGitlab Tutorial 3 - Continuous Integration (CI)\n\n\nAdditional details on basic customization of CI pipelines\n\n\nNov 16, 2023\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Tutorial-0.-Main-workflow.html",
    "href": "contents/tutorials/Tutorial-0.-Main-workflow.html",
    "title": "A Gitlab workflow to data sharing",
    "section": "",
    "text": "Back\n\nA Gitlab workflow to data sharing\nThe owner of the data (e.g., a lab or a researcher) creates, maintains and controls access to a main Gitlab repository containing:\n\nMetadata\nData, if applicable, e.g., raw images, thumbnail images etc.\nScripts to render an HTML landing site, i.e. the Data Hub, which provides access to the data for collaborators.\nDocumentation associated with the data in the Wiki of the repository. The markdown files composing the Wiki can be downloaded (they are physically stored in a separate repository) or they can be directly edited in the browser through the main repository.\n\nThe advantage of this Data Hub setup is that all material can be accessed by authorized collaborators through a browser:\n\nThe Data Hub, i.e. the landing page of the repository, provides interactive filtering capacities based on meta data and links to the available data.\nThe main repository to access and update, if necessary, the source metadata tables and data files\nThe Wiki to access all related documentation such as protocols and SOPs. The Wiki is linked from the landing page and accessible and editable through the main repository.\n\nNOTE FOR THE PICTURE: Write Data Hub and put it in the first line\n\n\n\nGitlab_basic\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html",
    "href": "contents/tutorials/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html",
    "title": "Tutorial 1: Using Gitlab for Project Owners and Collaborators",
    "section": "",
    "text": "Back"
  },
  {
    "objectID": "contents/tutorials/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#personal-access-token",
    "href": "contents/tutorials/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#personal-access-token",
    "title": "Tutorial 1: Using Gitlab for Project Owners and Collaborators",
    "section": "Personal access token",
    "text": "Personal access token\nTo clone a repository to your machine you will most likely need a personal access token (due to the security of SWITCH login). In your project repository on Gitlab.uzh.ch go to Settings/Access tokens. In the Access Tokens menu you will be able to give the token a name, choose an expiration date (or leave it blank), choose permissions (choose at least developer for making edits) and scope (select API). See also the picture below.\n\n\n\nimage\n\n\nAfter clicking on the button to create hthe access token you will see a long alphanumeric string, the token. Copy this string and save it somewhere so you can use it as your password later on when using Github-desktop, Git or any other platform to manage local copies of the repository."
  },
  {
    "objectID": "contents/tutorials/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-github-desktop-with-graphical-user-interface",
    "href": "contents/tutorials/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-github-desktop-with-graphical-user-interface",
    "title": "Tutorial 1: Using Gitlab for Project Owners and Collaborators",
    "section": "2.1 Cloning with GitHub Desktop (with graphical user interface)",
    "text": "2.1 Cloning with GitHub Desktop (with graphical user interface)\n\nSetup of GitHub Desktop for Gitlab\n\nDownload and install GitHub desktop\nIn your Gitlab project, get your personal access token (see above) and save it somewhere\nIn GitHub Desktop go to File/Clone repository. Then enter the URL of your Gitlab repository (see the clone button) and a local directory name. For example:\n\nNext you will be asked for username and password. Your username is your Gitlab username (e.g., the name in your email address) and the password is the token that you just created.\n\nNow your Local folder is linked to your Gitlab remote repository. You can check below how to pull, commit and push changes."
  },
  {
    "objectID": "contents/tutorials/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-git-using-command-line",
    "href": "contents/tutorials/Tutorial-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-git-using-command-line",
    "title": "Tutorial 1: Using Gitlab for Project Owners and Collaborators",
    "section": "2.2 Cloning with Git (using command line)",
    "text": "2.2 Cloning with Git (using command line)\nThe basic and cross-platform implementation of Git is distributed through Git SCM It is mostly designed for working through a command line interface. See the Git book mentioned above. Note that Rstudio interfaces directly with Git and provides a graphical user interface for Git as well."
  },
  {
    "objectID": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html",
    "href": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html",
    "title": "Tutorial 2: Creating and Updating a Data Hub in Gitlab",
    "section": "",
    "text": "Back"
  },
  {
    "objectID": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#action-data-owner-creates-data-hub-repository",
    "href": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#action-data-owner-creates-data-hub-repository",
    "title": "Tutorial 2: Creating and Updating a Data Hub in Gitlab",
    "section": "1. ACTION: Data owner creates Data Hub repository",
    "text": "1. ACTION: Data owner creates Data Hub repository\n–&gt; NOTE EF, THIS STEP IS MISSING: see the title of this tutorial! Refer to Tutorial 1? I take the sections that were at the bottom here\n\nNecessary files\nThe main input files for the Data Hub repository are:\n\nmetadata table (preferably in .csv format for interoperability). It should contain just the filenames and meta data of the pictures that will be displayed on the Data Hub.\nimage files. Note: Gitlab is not meant for data storage. Images should be compressed to avoid exceeding the volume allowed per repository ( usually 5 Gb in free versions, details here)\nR markdown script containing the code to render the interactive table\n.gitlab-ci.yml file specifying the Continuous Integration pipeline, see below.\n\nThe outputs of the Continuous Integration pipeline are\n\nindex.html file within the folder public. This is the landing page of the Data Hub.\nA folder files will be created if the table is rendered as self-contained –&gt; NOTE EF: do we need this?\n\n–&gt; NOTE EF we need to discuss this Note: index.html and images folder ARE EXPECTED to be saved in the public folder. This does not mean they are publicly accessible (you need login to access this site)"
  },
  {
    "objectID": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#action-owner-edits-metadata",
    "href": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#action-owner-edits-metadata",
    "title": "Tutorial 2: Creating and Updating a Data Hub in Gitlab",
    "section": "2. ACTION: Owner edits metadata",
    "text": "2. ACTION: Owner edits metadata\nThe owner can do this through:\n\nBrowser: Making changes in the repository in the browser (upload or edit file). This approach is recommended for minor changes.\nClone repository: Cloning the Data Hub repository, making changes locally and committing and pushing the changes to Gitlab (e.g., using Github desktop). The local meta data file should always be synchronized with the master copy in the remote repository. This approach is recommended for major changes."
  },
  {
    "objectID": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#auto-changes-in-the-repository-trigger-the-continuous-integration-pipeline",
    "href": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#auto-changes-in-the-repository-trigger-the-continuous-integration-pipeline",
    "title": "Tutorial 2: Creating and Updating a Data Hub in Gitlab",
    "section": "3. AUTO: changes in the repository trigger the Continuous Integration pipeline",
    "text": "3. AUTO: changes in the repository trigger the Continuous Integration pipeline\nAfter pushing changes to the Data Hub repository the Continuous Integration pipeline is triggered automatically. It may take around 5 minutes to update the web site. A team member with at least maintainer status can click on Build/Pipelines or Jobs (sidebar in Gitlab) to see what pipeline or job (within pipeline) is running, and if there are any errors."
  },
  {
    "objectID": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#auto-the-continuous-integration-pipeline-runs-the-script",
    "href": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#auto-the-continuous-integration-pipeline-runs-the-script",
    "title": "Tutorial 2: Creating and Updating a Data Hub in Gitlab",
    "section": "4. AUTO: the Continuous Integration pipeline runs the script",
    "text": "4. AUTO: the Continuous Integration pipeline runs the script\nThe .gitlab-ci.yml file defines the pipeline. It uses a Docker image containing R and a shared runner on the Gitlab server to run the Rmarkdown script on the Docker image. Gitlab pages is then used to host the website. The repository owner can edit the yml file and the Rmarkdown file to make changes to this workflow. Editing of the of the Docker image is not needed.\nSee our tutorial on customizing Gitlab Continuous Integration for more advanced details."
  },
  {
    "objectID": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#auto-the-data-hub-website-is-updated-and-collaborators-can-navigate-through-the-updated-data",
    "href": "contents/tutorials/Tutorial-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html#auto-the-data-hub-website-is-updated-and-collaborators-can-navigate-through-the-updated-data",
    "title": "Tutorial 2: Creating and Updating a Data Hub in Gitlab",
    "section": "5. AUTO: The Data Hub website is updated and collaborators can navigate through the updated data",
    "text": "5. AUTO: The Data Hub website is updated and collaborators can navigate through the updated data"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AFFORD",
    "section": "",
    "text": "This site compiles resources for Open Research Data management curated and developed by the Center of Reproducible Science of the University of Zurich for the SwissUniversities project AFFORD: A Framework for Avoiding Open Research Data Dump.\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\nLast edited: Thu Nov 16 14:56:54 2023\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Quarto_website/index.html",
    "href": "contents/tutorials/Quarto_website/index.html",
    "title": "Sharing dynamic reports in a website with R and Quarto",
    "section": "",
    "text": "Why is this relevant?\nSharing documents, code, data and outputs with collaborators or to a broader audience is an essential step towards a good scientific practice. A website that can be managed by researchers themselves seems the ideal platform for efficient sharing. If this depends on IT support for maintenance it will not be practical for routine use, but learning web-development imposes an unnecessary and unacceptable burden to a scientist’s already heavy workload.\nHere we describe an approach that uses free, open-source tools which are also widely-used for analytic purposes (e.g., data handling, statistics and visualizations). Thus, the requirements for learning web-specific tools is minimal. Importantly, this approach can be integrated in a research group’s routines to compile dynamic reports with documentation, code, analysis and outputs in a single-document. This makes each step easier to understand, facilitates troubleshooting and improves computational reproducibility see CRS primer\n\n\nSoftware required\nAll these tools are free and open source\n\nR: a widely-used software environment for statistical computing and graphics\nRstudio: an interactive development environment to use for working with R. It includes a visual editor and essential features to facilitate code editing.Importantly it supports Quarto (see below)\nQuarto: it is multi-language tool to facilitate technical and scientific publishing. It is supported by Rstudio. In the quarto documents we will have text chunks (plain text with markdown syntax, see note below) and code chunks (written in R, but it can also be other languages). This is an evolution of Rmarkdown with more functions, output options and more better interoperability between languages and environments. For the user, working with Quarto and Rmarkdown is quite similar, with some minor differences in syntax\n\n\n\n\n\n\n\nDictionary\n\n\n\nSome terms that often pop up if you search for documentation on the tools above:\n\nIDE: interactive development environment, this is an application that help us develop code more efficiently. They have features like syntax highlighting, intelligent code completion, debugging tools, etc.\nMarkdown: it is a markup language, that is, a set of symbols inserted in a text document to control structure, formatting and how its parts relate to each other. Markdown syntax is very simple and easy for humans to read. It allows us to write stuff in plain-text in a way that can be transformed into formatted text by other tools.\nPandoc: this is a program integrated in R studio that renders markdown text into other output formats like pdf, html word , etc)\nKnitr: this is the engine that executes the code chunks in a Quarto or Rmarkdown document. It can be installed as a package in R\nyaml or yml: YAML is a human-readable language used for configuration files. Here we use a .yml file to configure our site and a yml header to add settings and metadata on top of each quarto file\n\n\n\n\n\nFiles needed\nAt least you will need the following:\n\nA _quarto.yml configuration file (required filename & extension)\nAn index.qmd quarto markdown (suggested filename)\n\n\n\nStep-by-step shorts\nAssuming you have installed RStudio and quarto\n\n1. Make a website from scratch in 5 minutes\nThis 5 minutes video shows how easy it is to create the basic skeleton of the website.\n\nStep 1. Make a new folder for your website\nInside the folder you will have the _quarto.yml file at the top level, then you can organize the quarto markdown files with the content in subfolders if you want.\n\n\nStep 2. Create a _quarto.yml file with some settings\nThey are given in plain text. Indentation counts. There are many examples online which would require minimal adjustments. A very simple example:\nproject:\n    type: website\n    \nwebsite:\n    navbar:\n        title: Home\n        \nformat: \n    html:\n        author: Center for Reproducible Science\n“navbar” indicates a navigation bar on top of the website, but you can also define a “sidebar”. In there you can refer to the different pages that will make up your site. In this example we just make an skeleton with the home page.\n\n\nStep 3. Create a quarto (.qmd) file and open it in R studio\nWe recommend creating an R project file in Rstudio to point at your web’s folder and open your quarto files with that project open in Rstudio to avoid having future problems finding the path to your files.\nYou can write plain text with markdown syntax on it and use a yml header delimited by --- symbols to add metadata or settings\n\n\nStep 4. Click render\nThat’s it. A new subfolder named _site will be created with a file index.html which is your website\n\n\n\n\n2. Add pages and lists of pages within your website\n\n\n3. Host it for free using Gitlab pages\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Quarto_website/index.html#minimal-example",
    "href": "contents/tutorials/Quarto_website/index.html#minimal-example",
    "title": "Sharing dynamic reports in a website with R and Quarto",
    "section": "Minimal example",
    "text": "Minimal example\nAt least you will need the following:\n\nA _quarto.yml configuration file (required filename & extension)\nAn index.qmd quarto markdown (suggested filename)"
  },
  {
    "objectID": "contents/tutorials/Quarto_website/index.html#minimal-example-1",
    "href": "contents/tutorials/Quarto_website/index.html#minimal-example-1",
    "title": "Making a website with Quarto and R",
    "section": "Minimal example",
    "text": "Minimal example"
  },
  {
    "objectID": "contents/tutorials/Tutorial_Web.html",
    "href": "contents/tutorials/Tutorial_Web.html",
    "title": "Easy-to-build website with R and Quarto",
    "section": "",
    "text": "Why is this relevant?\nSharing documents, code, data and outputs with collaborators or to a broader audience is an essential step towards a good scientific practice. A website that can be managed by researchers themselves seems the ideal platform for efficient sharing. If this depends on IT support for maintenance it will not be practical for routine use, but learning web-development imposes an unnecessary and unacceptable burden to a scientist’s already heavy workload.\nHere we describe an approach that uses free, open-source tools which are also widely-used for analytic purposes (e.g., data handling, statistics and visualizations). Thus, the requirements for learning web-specific tools is minimal. Importantly, this approach can be integrated in a research group’s routines to compile dynamic reports with documentation, code, analysis and outputs in a single-document. This makes each step easier to understand, facilitates troubleshooting and improves computational reproducibility see CRS primer\n\n\nSoftware required\nAll these tools are free and open source\n\nR: a widely-used software environment for statistical computing and graphics\nRstudio: an interactive development environment to use for working with R. It includes a visual editor and essential features to facilitate code editing.Importantly it supports Quarto (see below)\nQuarto: it is multi-language tool to facilitate technical and scientific publishing. It is supported by Rstudio. In the quarto documents we will have text chunks (plain text with markdown syntax, see note below) and code chunks (written in R, but it can also be other languages). This is an evolution of Rmarkdown with more functions, output options and more better interoperability between languages and environments. For the user, working with Quarto and Rmarkdown is quite similar, with some minor differences in syntax\n\n\n\n\n\n\n\nDictionary\n\n\n\nSome terms that often pop up if you search for documentation on the tools above:\n\nIDE: interactive development environment, this is an application that help us develop code more efficiently. They have features like syntax highlighting, intelligent code completion, debugging tools, etc.\nMarkdown: it is a markup language, that is, a set of symbols inserted in a text document to control structure, formatting and how its parts relate to each other. Markdown syntax is very simple and easy for humans to read. It allows us to write stuff in plain-text in a way that can be transformed into formatted text by other tools.\nPandoc: this is a program integrated in R studio that renders markdown text into other output formats like pdf, html word , etc)\nKnitr: this is the engine that executes the code chunks in a Quarto or Rmarkdown document. It can be installed as a package in R\nyaml or yml: YAML is a human-readable language used for configuration files. Here we use a .yml file to configure our site and a yml header to add settings and metadata on top of each quarto file\n\n\n\n\n\nFiles needed\nAt least you will need the following:\n\nA _quarto.yml configuration file (required filename & extension)\nAn index.qmd quarto markdown (suggested filename)\n\n\n\nStep-by-step shorts\nAssuming you have installed RStudio and quarto\n\n1. Make a website from scratch in 5 minutes\nThis 5 minutes video shows how easy it is to create the basic skeleton of the website.\n\nStep 1. Make a new folder for your website\nInside the folder you will have the _quarto.yml file at the top level, then you can organize the quarto markdown files with the content in subfolders if you want.\n\n\nStep 2. Create a _quarto.yml file with some settings\nThey are given in plain text. Indentation counts. There are many examples online which would require minimal adjustments. A very simple example:\nproject:\n    type: website\n    \nwebsite:\n    navbar:\n        title: Home\n        \nformat: \n    html:\n        author: Center for Reproducible Science\n“navbar” indicates a navigation bar on top of the website, but you can also define a “sidebar”. In there you can refer to the different pages that will make up your site. In this example we just make an skeleton with the home page.\n\n\nStep 3. Create a quarto file and open it in R studio\nWe recommend creating an R project file in Rstudio to point at your web’s folder and open your quarto files with that project open in Rstudio to avoid having future problems finding the path to your files.\nYou can write plain text with markdown syntax on it and use a yml header delimited by --- symbols to add metadata or settings\n\n\nStep 4. Click render\nThat’s it. A new subfolder named _site will be created with a file index.html which is your website\n\n\n\n\n2. Add pages and lists of pages within your website\n\n\n3. Host it for free using Gitlab pages\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-3.-Customizing-Gitlab-Continuous-Integration.html",
    "href": "contents/tutorials/Tutorial_Gitlab-3.-Customizing-Gitlab-Continuous-Integration.html",
    "title": "Gitlab Tutorial 3 - Continuous Integration (CI)",
    "section": "",
    "text": "Back\nContinuous integration (CI) refers to the process of automating the integration of changes made by different developers working in the code. In the context of using Gitlab pages as a data hub, the CI will integrating changes in the metadata table and/or images into the resulting HTML. That is, it will update our website so that it shows the last version of our metadata and include any change we want in its content. The advantage is that users do not require to install any software dependencies (like R) and changes can be implemented using the browser, from any computer.\nSimplifying this There are 2 main elements we need to set up for Gitlab CI:\n\n1. Gitlab Runner\nThis is the service that will execute whatever operation you want to do in your CI pipeline. In this case we will use a shared-runner that is supported by the UZH. We only have this if we have our gitlab repository as part of the UZH Gitlab. We can also use our own runners but that is more complicated and beyond the scope of this tutorial (see Gitlab official documentation)\nYou can enable the shared-runner in your repository Settings&gt; CI/CD &gt; Runners. If you are using the UZH Gitlab there should be an available runner listed on the Shared runners section\n\n\n\n2. The .gitlab-ci.yml file\nThis file will define a pipeline which will run every time we make a change in the repository. A pipeline can have one or multiple jobs defined by a script. In our case the pipeline will have one job: rendering a website.\nThere are examples and Continous Integration templates of this file online. They all need an image of a software environment, some jobs defined by a script and some artifacts that are output files from the jobs. The example below uses an image from and it is nased on a template taken from Rocker, which is a project offering docker containers for R environments. Broadly speaking, we can think of a docker container as a light-weight virtual machine and of a docker image as a snapshot of a virtual machine, what defines its software contents.\nBelow we show and describe the following example:\nimage: rocker/verse:4.3\n\npages:\n  stage: deploy\n  before_script:\n   - R -e \"install.packages('quarto')\" \n   - R -e \"install.packages('kableExtra')\" \n   - R -e \"install.packages('DT')\"  \n   - mkdir -p public/SPring/Images\n   - cp _data/SPring/Images/* public/SPring/Images/   \n  \n  script:   \n   - cd _scripts\n   - R -e \"baseDir &lt;- getwd(); quarto::quarto_render('*.qmd')\"\n   - mv ./_site/* ../public/ \n  \n  artifacts:    \n    paths:\n    - public    \n     \n  only:\n  - master\n  interruptible: true\n\nImage\n\nThe first part loads a docker container image, similar to a snapshot of a virtual machine, which will define a software environment.\n\n\n\nPages\n\nWe define different stages (deploy is the main, but some tests stages are usually included as well).\nBecause our image did not include some R packages that we need, we install them in the before the script section. The following lines after installing packages are to create a new folder with copies of the pictures that will be rendered in the website, in the ‘public’ folder (see below, this is the folder where the website html needs to be stored).\nThen the script to actually do the job. First for convenience here we set the _scripts folder as our current directory. Then we run the R code using the R quarto package to build a website by using the command quarto_render indicating all .qmd files in the folder. In our case the .qmd contain text and code to read tables with metadata (see our tutorial on how to make a website with Quarto). The quarto_render() command will automatically create a _site folder with the website. If we change a table or the text in one of those files, this will run again and generate the site again.\nWe then move the content of the website to the public folder. This is necessary as Gitlab pages will only display the content of that folder\n\n\n\n\n\n\n\nNote\n\n\n\nAlthough it is called ‘public’ it does not mean that the page will be publicly available. Gitlab allows pages in private repository so that only people with access can see the content.\n\n\n\nThe job artifacts are the outputs, which in this case it will be the copy of the image files and the website HTMLs rendered by quarto. We define the path where we want those outputs as the ‘public’ folder for it to work with Gitlab pages\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-3.-Customizing-Gitlab-Continuous-Integration.html#the-.gitlab-ci.yml-file",
    "href": "contents/tutorials/Tutorial_Gitlab-3.-Customizing-Gitlab-Continuous-Integration.html#the-.gitlab-ci.yml-file",
    "title": "Gitlab Tutorial 3 - Continuous Integration (CI)",
    "section": "The .gitlab-ci.yml file",
    "text": "The .gitlab-ci.yml file\nimage: rocker/verse:4.3\n\npages:\n  stage: deploy\n  before_script:\n   - R -e \"install.packages('quarto')\" \n   - R -e \"install.packages('kableExtra')\" \n   - R -e \"install.packages('DT')\"  \n   - mkdir -p public/SPring/Images\n   - cp _data/SPring/Images/* public/SPring/Images/   \n  \n  script:   \n   - cd _scripts\n   - R -e \"baseDir &lt;- getwd(); quarto::quarto_render('*.qmd')\"\n   - mv ./_site/* ../public/ \n  \n  artifacts:    \n    paths:\n    - public    \n     \n  only:\n  - master\n  interruptible: true\n\nImage\n\nThe first part loads a docker container image, similar to a snapshot of a virtual machine, which will define a software environment.\n\n\n\nPages\n\nWe define different stages (deploy is the main, but some tests stages are usually included as well).\nBecause our image did not include some R packages that we need, we install them in the before the script section.\nThen the main script in this example runs some R code, using the R quarto package to build a website by using the command quarto_render indicating all .qmd files in the folder. In our case the .qmd contain text and code to read tables with metadata (see our tutorial on how to make a website with Quarto). The quarto_render() command will automatically create a _site folder with the website. If we change a table or the text in one of those files, this will run again and generate the site again\nWe then move the content of the website to the public folder. This is necessary as Gitlab pages will only display the content of that folder\n\n\n\n\n\n\n\nNote\n\n\n\nAlthough it is called ‘public’ it does not mean that the page will be publicly available. Gitlab allows pages in private repository so that only people with access can see the content.\n\n\n\nartifacts ."
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html",
    "href": "contents/tutorials/Tutorial_Gitlab-2.-Creating-and-Updating-a-Data-Hub-in-Gitlab.html",
    "title": "Gitlab Tutorial 2 - Creating and Updating a Data Hub",
    "section": "",
    "text": "Back\nA static site like the one you are seeing this tutorial can include interactive elements. In this example we propose an interactive table that can be used to navigate through metadata and even some data (e.g., displaying clickable image thumbnails). By static we mean that the user will just see whatever data is contained in the HTML of the site. Although it contains an interactive table, all users have access to the same data which they cannot modify (unlike in dynamic websites).\nThe website hosted using Gitlab pages is rendered with an [R Markdown] (https://rmarkdown.rstudio.com/) script, that uses the R DT package). The script creates an interactive page in HTML. Gitlab CI is used to run the R Markdown script automatically at each update (push) and render the site from the browser so that users do not need to install R or other programs to update the site.\n\nWorkflow for data owners\n\n\n1. ACTION: Owner edits metadata\nThe owner can do this through:\n\nBrowser (RECOMMENDED FOR MINOR CHANGES) Making changes from Gitlab in the browser (upload or edit file)\nClone repository (RECOMMENDED FOR MAJOR UPDATES) Cloning this repo, working locally and committing and pushing the changes to Gitlab (e.g., using Github desktop). The local metadata file should be always in Sync with that one in the remote repository.\n\nNOTE: The files in the Gitlab repository should be considered as the main source for retrieving your projects’ metadata.\n\n\n2. AUTO: changes in the repository trigger the Continuous Integration pipeline\nIt may take around 5 minutes to update the page html. The member with at least maintainer status can click on Build/Pipelines or Jobs (sidebar in Gitlab) to see what pipeline or job (within pipeline) is running, and if there are any errors.\n\n\n3. AUTO: the continuous integration pipeline runs the script\nThe .gitlab-ci.yml file defines this pipeline. It uses a Docker image with R, Gitlab pages to produce the website, and Gitlab runner to run the Docker where we have our Rmarkdown script (rendering the html from the table). The owner can edit the yml and the Rmarkdown to make if changes in this flow are to be done. No edit of Docker image is needed.\nSee our tutorial on customizing Gitlab Continuous Integration for more advanced details.\n\n\n4. AUTO: The HTML is updated and collaborators can navigate through the updated data\n\n\n\nFiles\nThe main input files are:\n\nmetadata table (preferrably in .csv format for interoperability). It should contain just the filename of the pictures that will be displayed\nimages files (Note: Gitlab is not meant for data storage. Images should be compressed to avoid exceeding volume allowed per repo ( usually 5 Gb in free versions, details here)\nR markdown script that has the code to render the table with DT package\nA .gitlab-ci.yml file is the Continuous integration file that makes it possible to run the Rmd file and render the html again from Gitlab\n\nThe outputs for the website\n\nindex.html file within the public folder\nAn ’ files’ folder will be saved if the table is rendered as self-contained\n\nNote: index.html and images folder ARE EXPECTED to be saved in the public folder. This does not mean they are publicly accessible (you need login to access this site)\n\n\nPrivacy\nThis is a private repository and a private site\n\nAccounts. A SWITCH account is required to access the static website and the repository with the code to generate it\nMembers. A maintainer member in this repository can add new members (Go to Manage/Members). They must be also maintainer to be able to access the images after clicking on the table thumbnail. Guests can only see the thumbnails\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-0.-Main-workflow.html",
    "href": "contents/tutorials/Tutorial_Gitlab-0.-Main-workflow.html",
    "title": "Gitlab Tutorial 0 - Workflow",
    "section": "",
    "text": "Back\nHere we propose to use Gitlab pages to host an easy-to-build website where we can share documentation, metadata and some data (e.g., preview images) of our projects. The website can be either public or private, requiring users to log in. We propose that this approach can be useful to improve the research workflow in many labs and projects, irrespective of whether they have a strong programming focus.\nThe series of tutorials in this website explain the different processes required for this workflow. They include step-by-step guides, templates, video demos and links intended for non-coders, as well as other tutorials for more advanced users.\nThe main requirements for this workflow are:\nThe basic workflow:\nflowchart TD\n    A1[data, metadata, code] &lt;.-&gt; |sync| B[Gitlab Repository]\n    B0[Documentation] &lt;.-&gt;|edit Wiki| B\n    B --&gt; | Render| C[GitlabPage]"
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html",
    "href": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html",
    "title": "Gitlab Tutorial 1 - short step-by-step guide to Git and Gitlab",
    "section": "",
    "text": "Back\nThis Tutorial is a short step-by-step guide on using Git and Gitlab and provides a workflow to use Github Desktop to sync with local files. For complete beginners we recommend the Git book, which is very accessible but also very detailed. It is available in several languages and as pdf. Another option for beginners are the Gitlab tutorials by Gitlab.com (commercial).\nGit is a system to track changes in files, it is most often used to coordinate the work among several persons who access the files online on a server or sync them to their computer. The online use does not require any installation, local use is only possible after installing Git.\nGitlab.com and Github.com are commercial hosting services for version control with Git. The UZH instance of the open source Gitlab at Gitlab.uzh.ch is hosted by the UZH on servers owned by SWITCH, a non-profit foundation that has been established by the Swiss Federal Government. See https://www.zi.uzh.ch/en/staff/software-elearning/webplatforms/gitlab.html for more information.\nA Git repository is a set of folders and files with complete history and full version-tracking abilities, locally or on a server."
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#personal-access-token",
    "href": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#personal-access-token",
    "title": "Gitlab Tutorial 1 - short step-by-step guide to Git and Gitlab",
    "section": "Personal access token",
    "text": "Personal access token\nTo clone a repository to your machine you will most likely need a personal access token (due to the security of SWITCH login). In your project repository on Gitlab.uzh.ch go to Settings/Access tokens. In the Access Tokens menu you will be able to give the token a name, choose an expiration date (or leave it blank), choose permissions (choose at least developer for making edits) and scope (select API). See also the picture below.\n\n\n\nimage\n\n\nAfter this you will see a long alphanumeric string, the token, that you should save somewhere so you can use it as your password later on when using Github-desktop, Git or any other platform to manage local copies of the repositories."
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-github-desktop-user-friendly",
    "href": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-github-desktop-user-friendly",
    "title": "Gitlab Tutorial 1 - short step-by-step guide to Git and Gitlab",
    "section": "2.1 Cloning with Github-desktop (user-friendly)",
    "text": "2.1 Cloning with Github-desktop (user-friendly)\nThe open source tool Github-desktop with a graphical user interface will simplify pull, commit, push operations for both advanced as well as new users. !Note: official support seems to be only for Windows and Mac. See further documentation on integration with Gitlab\n\nSetup of Github-desktop for Gitlab\n\nDownload and install Github desktop\nIn your Gitlab project, get your personal access token (see above) and save it somewhere\nOn Github desktop go to File/Clone repository. Then enter the URL of your Gitlab repository (see the clone button) and a local directory name. For example:\n\nThen you will be asked for username and password. Your username is your Gitlab username (e.g., the name in your email address) and the password is the Token that you just created.\n\nNow your Local folder is linked to your Gitlab remote repository. You can check below how to pull, commit and push changes.\n\n\nEditing repository\nPull,commit and Push changes in the content of the repository. The workflow can get quite complex. Here we will ignore elements like branches to oversimplify it into the main steps:\n\nWork on your local repository, for example, create or edit code, update your metadata table, add new files [^1]\nOpen Github desktop. If you have several repositories, make sure you select the one you are currently working on or the one you want to update. It should detect the local changes done. If there are changes done remotely, but not locally, it willl prompt you to pull those changes (but here, beware there may be conflicts, which you shold be able to solve with Github but may complicate things).\nClick Commit ( you will need to write a brief description, e.g., ‘updated figures’). This will prepare your changes to be sent to the remote repository (‘origin’). If you edited multiple scripts, you can commit all changes at once or select specific scripts\nClick push to origin so that the changes are uploaded.\n\n[^1]: Gitlab is not intended as a large data storage. For the pages in this example we need to have the pictures we want to render in the repository. But sometimes we have many files in our local repository that we do not want to push to the online repository. For that we can use a plain text file in that directory and call it .gitignore. In that file we can have statements like ‘*.jpg’. Then Git will ignore all jpg files in the folder when pushing."
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-git",
    "href": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-git",
    "title": "Gitlab Tutorial 1: Using a UZH Gitlab repository for Project Owners and Collaborators",
    "section": "2.2 Cloning with Git",
    "text": "2.2 Cloning with Git\nGit refers to this version control system used in Gitlab, but you can also manage the repositories locally downloading the program Git SCM, a free and open source distributed version control system. It is light and works across operating systems, and also has a very basic graphical interface. But it is mostly designed for working through a terminal. As in Github-desktop you use this to do the main Git actions of pulling, committing and pushing changes between local and remote repositories."
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-git-using-command-line",
    "href": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#cloning-with-git-using-command-line",
    "title": "Gitlab Tutorial 1 - short step-by-step guide to Git and Gitlab",
    "section": "2.2 Cloning with Git (using command line)",
    "text": "2.2 Cloning with Git (using command line)\nGit refers to this version control system used in Gitlab, but you can also manage the repositories locally downloading the program Git SCM, a free and open source distributed version control system. It is light and works across operating systems, and also has a very basic graphical interface. But it is mostly designed for working through a terminal. As in Github-desktop you use this to do the main Git actions of pulling, committing and pushing changes between local and remote repositories."
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-0.-Main-workflow.html#simplified-workflow",
    "href": "contents/tutorials/Tutorial_Gitlab-0.-Main-workflow.html#simplified-workflow",
    "title": "Gitlab Tutorial 0 - workflow",
    "section": "Simplified workflow",
    "text": "Simplified workflow\n\n\n\n\nflowchart TD\n    A1[data, metadata, code] &lt;.-&gt; |sync| B[Gitlab Repository]\n    B0[Repository Wiki] &lt;.-&gt;|edit in browser| B\n    B --&gt; | Render| C[GitlabPage]"
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-0.-Main-workflow.html#detailed-workflow",
    "href": "contents/tutorials/Tutorial_Gitlab-0.-Main-workflow.html#detailed-workflow",
    "title": "Gitlab Tutorial 0 - Workflow",
    "section": "Detailed workflow",
    "text": "Detailed workflow\nThe owner of the data (e.g., a lab or a researcher) creates and maintains a main Gitlab repository containing:\n\nMetadata\nData, if applicable, e.g., thumbnail images\nScripts to render an HTML landing site, i.e. the Data Hub, which provides access for collaborators. This can be done without web development skill using in R markdown or R Quarto markdown.\nDocumentation associated with those data is collected in the Wiki of the main repository. The advantage of using the Wiki is that it can be directly edited in the browser by anyone with permissions. If needed, the markdown files with the wiki pages could be downloaded (they are stored is a separate repository).\n\nThe materials will have three URL locations, which can all be accessed through the main landing site (Data Hub):\n\nThe Landing page shows interactive tables to navigate data and metadata the documentation and has links to the main repository and the wiki.\nThe main repository to access the source metadata tables, data files and the code necessary to generate the Hub.\nThe Wiki to access all relevant documentation to understand how the data was collected and preprocessed, such as protocols and standard operating procedures (SOPs). It should also have information about filenames, folder structures and how metadata are organized. It is also accessible through the main repository.\n\nAny user/collaborator is given the landing page address and access credentials to it. From there they can access the three urls."
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#for-project-owners-1",
    "href": "contents/tutorials/Tutorial_Gitlab-1.-Using-Gitlab-for-Project-Owners-and-Collaborators.html#for-project-owners-1",
    "title": "Gitlab Tutorial 1 - short step-by-step guide to Git and Gitlab",
    "section": "For project owners",
    "text": "For project owners\nOur remote Gitlab repository, which we access via the browser is now our main location of metadata, code and (some) data. But sometimes it is convenient to make our edits locally. Specially if we are data owners and want to edit and share a large number of files or code, we cannot do this easily in the browser. Recall that you need to install Git for this.\nIn Git, you can clone a repository to create a copy on your computer, that will be synchronized with your remote repository. Once cloned we can pull changes done in the remote repository (in the browser). If we have local changes and want to ‘send’ them to the remote we do: 1) commit and 2) push the local changes to remote. (??? what about add?)\nNOTE: if we fork a repository instead of cloning it, this will create a completely independent copy of the Git repository. Here, we need cloning so that our local changes can be synchronized and we don’t create duplicates of the repository."
  },
  {
    "objectID": "contents/tutorials/Tutorial_Gitlab-3.-Customizing-Gitlab-Continuous-Integration.html#the-.gitlab-ci.yml-file-1",
    "href": "contents/tutorials/Tutorial_Gitlab-3.-Customizing-Gitlab-Continuous-Integration.html#the-.gitlab-ci.yml-file-1",
    "title": "Gitlab Tutorial 3 - Continuous Integration (CI)",
    "section": "The .gitlab-ci.yml file",
    "text": "The .gitlab-ci.yml file\nimage: rocker/verse:4.3\n\npages:\n  stage: deploy\n  before_script:\n   - R -e \"install.packages('quarto')\" \n   - R -e \"install.packages('kableExtra')\" \n   - R -e \"install.packages('DT')\"  \n   - mkdir -p public/SPring/Images\n   - cp _data/SPring/Images/* public/SPring/Images/   \n  \n  script:   \n   - cd _scripts\n   - R -e \"baseDir &lt;- getwd(); quarto::quarto_render('*.qmd')\"\n   - mv ./_site/* ../public/ \n  \n  artifacts:    \n    paths:\n    - public    \n     \n  only:\n  - master\n  interruptible: true\n\nImage\n\nThe first part loads a docker container image, similar to a snapshot of a virtual machine, which will define a software environment.\n\n\n\nPages\n\nWe define different stages (deploy is the main, but some tests stages are usually included as well).\nBecause our image did not include some R packages that we need, we install them in the before the script section.\nThen the main script in this example runs some R code, using the R quarto package to build a website by using the command quarto_render indicating all .qmd files in the folder. In our case the .qmd contain text and code to read tables with metadata (see our tutorial on how to make a website with Quarto). The quarto_render() command will automatically create a _site folder with the website. If we change a table or the text in one of those files, this will run again and generate the site again\nWe then move the content of the website to the public folder. This is necessary as Gitlab pages will only display the content of that folder\n\n\n\n\n\n\n\nNote\n\n\n\nAlthough it is called ‘public’ it does not mean that the page will be publicly available. Gitlab allows pages in private repository so that only people with access can see the content.\n\n\n\nartifacts ."
  }
]